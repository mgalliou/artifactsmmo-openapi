/*
 * Artifacts API
 *
 *  Artifacts is an API-based MMO game where you can manage 5 characters to explore, fight, gather resources, craft items and much more.  Website: https://artifactsmmo.com/  Documentation: https://docs.artifactsmmo.com/  OpenAPI Spec: https://api.artifactsmmo.com/openapi.json 
 *
 * The version of the OpenAPI document: 4.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`action_accept_new_task_my_name_action_task_new_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionAcceptNewTaskMyNameActionTaskNewPostError {
    Status498(),
    Status499(),
    Status486(),
    Status598(),
    Status489(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_buy_bank_expansion_my_name_action_bank_buy_expansion_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionBuyBankExpansionMyNameActionBankBuyExpansionPostError {
    Status598(),
    Status498(),
    Status499(),
    Status486(),
    Status492(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_complete_task_my_name_action_task_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionCompleteTaskMyNameActionTaskCompletePostError {
    Status498(),
    Status499(),
    Status486(),
    Status598(),
    Status488(),
    Status487(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_crafting_my_name_action_crafting_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionCraftingMyNameActionCraftingPostError {
    Status404(),
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status486(),
    Status493(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_delete_item_my_name_action_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDeleteItemMyNameActionDeletePostError {
    Status498(),
    Status499(),
    Status486(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_deposit_bank_gold_my_name_action_bank_deposit_gold_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDepositBankGoldMyNameActionBankDepositGoldPostError {
    Status598(),
    Status492(),
    Status498(),
    Status499(),
    Status461(),
    Status486(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_deposit_bank_my_name_action_bank_deposit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDepositBankMyNameActionBankDepositPostError {
    Status598(),
    Status404(),
    Status461(),
    Status498(),
    Status499(),
    Status486(),
    Status478(),
    Status462(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_equip_item_my_name_action_equip_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionEquipItemMyNameActionEquipPostError {
    Status404(),
    Status498(),
    Status499(),
    Status486(),
    Status478(),
    Status496(),
    Status491(),
    Status485(),
    Status484(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_fight_my_name_action_fight_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionFightMyNameActionFightPostError {
    Status498(),
    Status499(),
    Status598(),
    Status486(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_gathering_my_name_action_gathering_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGatheringMyNameActionGatheringPostError {
    Status498(),
    Status499(),
    Status598(),
    Status486(),
    Status493(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_ge_buy_item_my_name_action_grandexchange_buy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGeBuyItemMyNameActionGrandexchangeBuyPostError {
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status436(),
    Status486(),
    Status492(),
    Status434(),
    Status435(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_ge_cancel_sell_order_my_name_action_grandexchange_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostError {
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status436(),
    Status486(),
    Status438(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_ge_create_sell_order_my_name_action_grandexchange_sell_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostError {
    Status498(),
    Status499(),
    Status486(),
    Status404(),
    Status478(),
    Status492(),
    Status433(),
    Status437(),
    Status598(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_move_my_name_action_move_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionMoveMyNameActionMovePostError {
    Status498(),
    Status499(),
    Status490(),
    Status404(),
    Status486(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_npc_buy_item_my_name_action_npc_buy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionNpcBuyItemMyNameActionNpcBuyPostError {
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status486(),
    Status492(),
    Status441(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_npc_sell_item_my_name_action_npc_sell_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionNpcSellItemMyNameActionNpcSellPostError {
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status486(),
    Status478(),
    Status442(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_recycling_my_name_action_recycling_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionRecyclingMyNameActionRecyclingPostError {
    Status404(),
    Status598(),
    Status498(),
    Status497(),
    Status499(),
    Status486(),
    Status493(),
    Status478(),
    Status473(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_rest_my_name_action_rest_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionRestMyNameActionRestPostError {
    Status498(),
    Status499(),
    Status486(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_task_cancel_my_name_action_task_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionTaskCancelMyNameActionTaskCancelPostError {
    Status498(),
    Status499(),
    Status486(),
    Status598(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_task_exchange_my_name_action_task_exchange_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionTaskExchangeMyNameActionTaskExchangePostError {
    Status498(),
    Status499(),
    Status486(),
    Status598(),
    Status478(),
    Status497(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_task_trade_my_name_action_task_trade_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionTaskTradeMyNameActionTaskTradePostError {
    Status498(),
    Status499(),
    Status486(),
    Status598(),
    Status475(),
    Status474(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_unequip_item_my_name_action_unequip_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionUnequipItemMyNameActionUnequipPostError {
    Status404(),
    Status498(),
    Status486(),
    Status491(),
    Status497(),
    Status478(),
    Status483(),
    Status499(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_use_item_my_name_action_use_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionUseItemMyNameActionUsePostError {
    Status404(),
    Status498(),
    Status499(),
    Status486(),
    Status476(),
    Status478(),
    Status496(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_withdraw_bank_gold_my_name_action_bank_withdraw_gold_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError {
    Status498(),
    Status499(),
    Status461(),
    Status486(),
    Status598(),
    Status460(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_withdraw_bank_my_name_action_bank_withdraw_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionWithdrawBankMyNameActionBankWithdrawPostError {
    Status404(),
    Status498(),
    Status499(),
    Status461(),
    Status486(),
    Status497(),
    Status598(),
    Status478(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_characters_logs_my_logs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllCharactersLogsMyLogsGetError {
    Status404(),
    Status498(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_characters_my_characters_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyCharactersMyCharactersGetError {
    UnknownValue(serde_json::Value),
}


/// Accepting a new task.
pub fn action_accept_new_task_my_name_action_task_new_post(configuration: &configuration::Configuration, name: &str) -> Result<models::TaskResponseSchema, Error<ActionAcceptNewTaskMyNameActionTaskNewPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/my/{name}/action/task/new", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionAcceptNewTaskMyNameActionTaskNewPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Buy a 20 slots bank expansion.
pub fn action_buy_bank_expansion_my_name_action_bank_buy_expansion_post(configuration: &configuration::Configuration, name: &str) -> Result<models::BankExtensionTransactionResponseSchema, Error<ActionBuyBankExpansionMyNameActionBankBuyExpansionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/my/{name}/action/bank/buy_expansion", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankExtensionTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankExtensionTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionBuyBankExpansionMyNameActionBankBuyExpansionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete a task.
pub fn action_complete_task_my_name_action_task_complete_post(configuration: &configuration::Configuration, name: &str) -> Result<models::RewardDataResponseSchema, Error<ActionCompleteTaskMyNameActionTaskCompletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/my/{name}/action/task/complete", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RewardDataResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RewardDataResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionCompleteTaskMyNameActionTaskCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Crafting an item. The character must be on a map with a workshop.
pub fn action_crafting_my_name_action_crafting_post(configuration: &configuration::Configuration, name: &str, crafting_schema: models::CraftingSchema) -> Result<models::SkillResponseSchema, Error<ActionCraftingMyNameActionCraftingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_crafting_schema = crafting_schema;

    let uri_str = format!("{}/my/{name}/action/crafting", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_crafting_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SkillResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SkillResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionCraftingMyNameActionCraftingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an item from your character's inventory.
pub fn action_delete_item_my_name_action_delete_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: models::SimpleItemSchema) -> Result<models::DeleteItemResponseSchema, Error<ActionDeleteItemMyNameActionDeletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/delete", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteItemResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteItemResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionDeleteItemMyNameActionDeletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deposit gold in a bank on the character's map.
pub fn action_deposit_bank_gold_my_name_action_bank_deposit_gold_post(configuration: &configuration::Configuration, name: &str, deposit_withdraw_gold_schema: models::DepositWithdrawGoldSchema) -> Result<models::BankGoldTransactionResponseSchema, Error<ActionDepositBankGoldMyNameActionBankDepositGoldPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_deposit_withdraw_gold_schema = deposit_withdraw_gold_schema;

    let uri_str = format!("{}/my/{name}/action/bank/deposit/gold", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_deposit_withdraw_gold_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankGoldTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankGoldTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionDepositBankGoldMyNameActionBankDepositGoldPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deposit an item in a bank on the character's map.
pub fn action_deposit_bank_my_name_action_bank_deposit_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: models::SimpleItemSchema) -> Result<models::BankItemTransactionResponseSchema, Error<ActionDepositBankMyNameActionBankDepositPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/bank/deposit", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankItemTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankItemTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionDepositBankMyNameActionBankDepositPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Equip an item on your character.
pub fn action_equip_item_my_name_action_equip_post(configuration: &configuration::Configuration, name: &str, equip_schema: models::EquipSchema) -> Result<models::EquipmentResponseSchema, Error<ActionEquipItemMyNameActionEquipPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_equip_schema = equip_schema;

    let uri_str = format!("{}/my/{name}/action/equip", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_equip_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EquipmentResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EquipmentResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionEquipItemMyNameActionEquipPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a fight against a monster on the character's map.
pub fn action_fight_my_name_action_fight_post(configuration: &configuration::Configuration, name: &str) -> Result<models::CharacterFightResponseSchema, Error<ActionFightMyNameActionFightPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/my/{name}/action/fight", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CharacterFightResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CharacterFightResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionFightMyNameActionFightPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Harvest a resource on the character's map.
pub fn action_gathering_my_name_action_gathering_post(configuration: &configuration::Configuration, name: &str) -> Result<models::SkillResponseSchema, Error<ActionGatheringMyNameActionGatheringPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/my/{name}/action/gathering", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SkillResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SkillResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGatheringMyNameActionGatheringPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Buy an item at the Grand Exchange on the character's map.
pub fn action_ge_buy_item_my_name_action_grandexchange_buy_post(configuration: &configuration::Configuration, name: &str, ge_buy_order_schema: models::GeBuyOrderSchema) -> Result<models::GeTransactionResponseSchema, Error<ActionGeBuyItemMyNameActionGrandexchangeBuyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_ge_buy_order_schema = ge_buy_order_schema;

    let uri_str = format!("{}/my/{name}/action/grandexchange/buy", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_ge_buy_order_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GeTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GeTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGeBuyItemMyNameActionGrandexchangeBuyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel a sell order at the Grand Exchange on the character's map.
pub fn action_ge_cancel_sell_order_my_name_action_grandexchange_cancel_post(configuration: &configuration::Configuration, name: &str, ge_cancel_order_schema: models::GeCancelOrderSchema) -> Result<models::GeTransactionResponseSchema, Error<ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_ge_cancel_order_schema = ge_cancel_order_schema;

    let uri_str = format!("{}/my/{name}/action/grandexchange/cancel", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_ge_cancel_order_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GeTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GeTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a sell order at the Grand Exchange on the character's map. Please note that a 5% sales tax is charged.
pub fn action_ge_create_sell_order_my_name_action_grandexchange_sell_post(configuration: &configuration::Configuration, name: &str, ge_order_creationr_schema: models::GeOrderCreationrSchema) -> Result<models::GeCreateOrderTransactionResponseSchema, Error<ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_ge_order_creationr_schema = ge_order_creationr_schema;

    let uri_str = format!("{}/my/{name}/action/grandexchange/sell", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_ge_order_creationr_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GeCreateOrderTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GeCreateOrderTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Moves a character on the map using the map's X and Y position.
pub fn action_move_my_name_action_move_post(configuration: &configuration::Configuration, name: &str, destination_schema: models::DestinationSchema) -> Result<models::CharacterMovementResponseSchema, Error<ActionMoveMyNameActionMovePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_destination_schema = destination_schema;

    let uri_str = format!("{}/my/{name}/action/move", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_destination_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CharacterMovementResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CharacterMovementResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionMoveMyNameActionMovePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Buy an item from an NPC on the character's map.
pub fn action_npc_buy_item_my_name_action_npc_buy_post(configuration: &configuration::Configuration, name: &str, npc_merchant_buy_schema: models::NpcMerchantBuySchema) -> Result<models::NpcMerchantTransactionResponseSchema, Error<ActionNpcBuyItemMyNameActionNpcBuyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_npc_merchant_buy_schema = npc_merchant_buy_schema;

    let uri_str = format!("{}/my/{name}/action/npc/buy", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_npc_merchant_buy_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NpcMerchantTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NpcMerchantTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionNpcBuyItemMyNameActionNpcBuyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sell an item to an NPC on the character's map.
pub fn action_npc_sell_item_my_name_action_npc_sell_post(configuration: &configuration::Configuration, name: &str, npc_merchant_buy_schema: models::NpcMerchantBuySchema) -> Result<models::NpcMerchantTransactionResponseSchema, Error<ActionNpcSellItemMyNameActionNpcSellPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_npc_merchant_buy_schema = npc_merchant_buy_schema;

    let uri_str = format!("{}/my/{name}/action/npc/sell", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_npc_merchant_buy_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NpcMerchantTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NpcMerchantTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionNpcSellItemMyNameActionNpcSellPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Recycling an item. The character must be on a map with a workshop (only for equipments and weapons).
pub fn action_recycling_my_name_action_recycling_post(configuration: &configuration::Configuration, name: &str, recycling_schema: models::RecyclingSchema) -> Result<models::RecyclingResponseSchema, Error<ActionRecyclingMyNameActionRecyclingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_recycling_schema = recycling_schema;

    let uri_str = format!("{}/my/{name}/action/recycling", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_recycling_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RecyclingResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RecyclingResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionRecyclingMyNameActionRecyclingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Recovers hit points by resting. (1 second per 5 HP, minimum 3 seconds)
pub fn action_rest_my_name_action_rest_post(configuration: &configuration::Configuration, name: &str) -> Result<models::CharacterRestResponseSchema, Error<ActionRestMyNameActionRestPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/my/{name}/action/rest", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CharacterRestResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CharacterRestResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionRestMyNameActionRestPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel a task for 1 tasks coin.
pub fn action_task_cancel_my_name_action_task_cancel_post(configuration: &configuration::Configuration, name: &str) -> Result<models::TaskCancelledResponseSchema, Error<ActionTaskCancelMyNameActionTaskCancelPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/my/{name}/action/task/cancel", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskCancelledResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskCancelledResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionTaskCancelMyNameActionTaskCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange 6 tasks coins for a random reward. Rewards are exclusive items or resources.
pub fn action_task_exchange_my_name_action_task_exchange_post(configuration: &configuration::Configuration, name: &str) -> Result<models::RewardDataResponseSchema, Error<ActionTaskExchangeMyNameActionTaskExchangePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/my/{name}/action/task/exchange", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RewardDataResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RewardDataResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionTaskExchangeMyNameActionTaskExchangePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Trading items with a Tasks Master.
pub fn action_task_trade_my_name_action_task_trade_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: models::SimpleItemSchema) -> Result<models::TaskTradeResponseSchema, Error<ActionTaskTradeMyNameActionTaskTradePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/task/trade", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskTradeResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskTradeResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionTaskTradeMyNameActionTaskTradePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unequip an item on your character.
pub fn action_unequip_item_my_name_action_unequip_post(configuration: &configuration::Configuration, name: &str, unequip_schema: models::UnequipSchema) -> Result<models::EquipmentResponseSchema, Error<ActionUnequipItemMyNameActionUnequipPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_unequip_schema = unequip_schema;

    let uri_str = format!("{}/my/{name}/action/unequip", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_unequip_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EquipmentResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EquipmentResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionUnequipItemMyNameActionUnequipPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use an item as a consumable.
pub fn action_use_item_my_name_action_use_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: models::SimpleItemSchema) -> Result<models::UseItemResponseSchema, Error<ActionUseItemMyNameActionUsePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/use", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UseItemResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UseItemResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionUseItemMyNameActionUsePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Withdraw gold from your bank.
pub fn action_withdraw_bank_gold_my_name_action_bank_withdraw_gold_post(configuration: &configuration::Configuration, name: &str, deposit_withdraw_gold_schema: models::DepositWithdrawGoldSchema) -> Result<models::BankGoldTransactionResponseSchema, Error<ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_deposit_withdraw_gold_schema = deposit_withdraw_gold_schema;

    let uri_str = format!("{}/my/{name}/action/bank/withdraw/gold", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_deposit_withdraw_gold_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankGoldTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankGoldTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take an item from your bank and put it in the character's inventory.
pub fn action_withdraw_bank_my_name_action_bank_withdraw_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: models::SimpleItemSchema) -> Result<models::BankItemTransactionResponseSchema, Error<ActionWithdrawBankMyNameActionBankWithdrawPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/bank/withdraw", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankItemTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankItemTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionWithdrawBankMyNameActionBankWithdrawPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// History of the last 100 actions of all your characters.
pub fn get_all_characters_logs_my_logs_get(configuration: &configuration::Configuration, page: Option<i32>, size: Option<i32>) -> Result<models::DataPageLogSchema, Error<GetAllCharactersLogsMyLogsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_size = size;

    let uri_str = format!("{}/my/logs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DataPageLogSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DataPageLogSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<GetAllCharactersLogsMyLogsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List of your characters.
pub fn get_my_characters_my_characters_get(configuration: &configuration::Configuration, ) -> Result<models::MyCharactersListSchema, Error<GetMyCharactersMyCharactersGetError>> {

    let uri_str = format!("{}/my/characters", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MyCharactersListSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MyCharactersListSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<GetMyCharactersMyCharactersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

